

Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 class组件的特性。

## useState

在函数组件中引入状态。

``` jsx live
function example(props) {
    let [count, setCount] = useState(0) // 初始值0
    return (
    	<div>
        	{ count }
            <button onClick={() => setCount(count + 1)}>
            	Click me
          	</button>
        </div>
    )
}
```

`useState`的参数也可以是一个函数。

``` js
const [state, setState] = useState(() => {
    return 0
})
```

## useEffect

在函数组件中执行副作用操作，可用于模拟`mounted`、`updated`生命周期钩子。

``` jsx live
function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

``` jsx
useEffetc(() => {}, []) // 只在挂载时执行
useEffect(() => {}, [count]) // 只在挂载和count改变时执行
useEffect(() => {}) // 在挂载和数据更新时执行
```

`useEffect`可以返回一个函数来清除副作用

``` javascript
useEffect(() => {
    // 运行副作用
    ChatAPI.subscribe()
    // 清除副作用
    return () => {
        ChatAPI.unsubscribe()
    }
})
```

组件挂载时，运行副作用（effect）；组件更新时，先清除上一个effect，再运行下一个effect；组件卸载时，清除最后一个effect

``` javascript
function FriendStatus(props) {
  // ...
  useEffect(() => {
    // ...
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
```

``` javascript
// Mount with { friend: { id: 100 } } props
ChatAPI.subscribeToFriendStatus(100, handleStatusChange);     // 运行第一个 effect

// Update with { friend: { id: 200 } } props
ChatAPI.unsubscribeFromFriendStatus(100, handleStatusChange); // 清除上一个 effect
ChatAPI.subscribeToFriendStatus(200, handleStatusChange);     // 运行下一个 effect

// Update with { friend: { id: 300 } } props
ChatAPI.unsubscribeFromFriendStatus(200, handleStatusChange); // 清除上一个 effect
ChatAPI.subscribeToFriendStatus(300, handleStatusChange);     // 运行下一个 effect

// Unmount
ChatAPI.unsubscribeFromFriendStatus(300, handleStatusChange); // 清除最后一个 effect
```

## useRef

在函数组件中引入`ref`

``` javascript
import React, { useRef } from 'react'

function App(props) {
    let refs = useRef(null)
    return (
    	<input ref={refs}>
    )
}
```

## useReducer

在函数组件中引入状态，类似`useState`但我们不是直接修改数据，而是通过`dispatch(action)`的形式修改数据。

``` jsx
function Todos() {
  const [todos, dispatch] = useReducer(todosReducer, []);

  function handleAddClick(text) {
    dispatch({ type: 'add', text });
  }

  // ...
}

function todosReducer(state, action) {
  switch (action.type) {
    case 'add':
      return [...state, {
        text: action.text,
        completed: false
      }];
    // ... other actions ...
    default:
      return state;
  }
}
```

`useReducer`的简单实现版本如下

```js
function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch(action) {
    const nextState = reducer(state, action);
    setState(nextState);
  }

  return [state, dispatch];
}
```

## useImperativeHandle

通常和`forwardRef`搭配使用，`forwardRef`能够暴露组件的内部DOM元素给外部使用，而`useImperativeHandle`能够限制我们只能访问DOM元素的哪些属性或方法。

比如以下代码，我们可以获取`FancyInput`组件内部的`input`元素，但是被限制只能使用`focus`来控制焦点。

``` js
// forwardRef + useImperativeHandle
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);
```

## useMemo

类似计算属性，根据依赖的变量缓存计算的结果。

``` js
const revertMsg = useMemo(() => msg.split('').reverse().join(''), [msg])
```



## useCallback

对于这样的一段代码，父组件将匿名函数（或普通函数）作为`props`传递给子组件。当父组件重新渲染，则会生成一个全新的匿名函数作为`props`传递给子组件，因此会**触发子组件的重新渲染**。

``` jsx
function Father () {
    const [count, setCount] = useState(0)
    return (
    	<PureChildComponent onClick={() => { setCount(1) }}/>
    )
}

// 或者

function Father () {
    const [count, setCount] = useState(0)
    function handleClick() {
        setCount(1)
    }
    return (
    	<PureChildComponent onClick={handleClick}/>
    )
}
```

为了解决这样的问题我们需要在函数组件中保存一个函数，而`useCallback`就是用来做这个的。

``` jsx
function Father () {
    const [count, setCount] = useState(0)
    const cb = useCallback(() => {
       setCount(count => count + 1)
    }, [])
    return (
    	<PureChildComponent onClick={cb}/>
    )
}
```

当然，实际上我们也可以用`useState`、`useMemo`来实现该功能，只是`useCallback`更加语义化。

``` jsx
// 使用useState（不推荐，只是一个思路）
function Father () {
    const [count, setCount] = useState(0)
    const [cb, setCb] = useState(() => () => setCount(count => count + 1))
    return (
    	<PureChildComponent onClick={cb}/>
    )
}
// 使用useMemo（不推荐，只是一个思路）
function Father () {
    const [count, setCount] = useState(0)
    const cb = useMemo(() => {
       return () => setCount(count => count + 1)
    }, [])
    return (
    	<PureChildComponent onClick={cb}/>
    )
}
```

> `useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`

## Hook闭包陷阱

在学习Hook的过程中，我们可能会听到这样的名词：“闭包陷阱”。那么什么是闭包陷阱呢，我们可以看一下以下几个代码的例子。

``` jsx live
// 测试代码1
function Test1() {
    const [count, setCount] = useState(0);
    useEffect(() => {
        setInterval(() => {
            console.log(count)
        }, 1000)
    }, []) // 空数组

    return (
        <div>
            {count}
            <button onClick={() => setCount(10)}>点我</button>
        </div>
    )
}
```

``` jsx live
// 测试代码2
function Test2() {
    const [count, setCount] = useState(0)
    const fn = useCallback(() => {
      alert(count)
    }, []) // 空数组
    return (
        <div>
            {count}
            <button onClick={() => setCount(100)}>点我</button>
            <button onClick={fn}>输出</button> // 输出的是0而不是100
        </div>
    )
}
``` 

``` jsx
// 测试代码3
function Test3() {
    const [count, setCount] = useState(0)
    useEffect(() => {
        store.subscribe(() => {
            setCount(count + 1)
            // setCount(count => count + 1)
        })
    }, [])    
    return (
        <div>
            { store.getState()}
            { count }
            <button onClick={() => { store.dispatch({type: 'asc', payload: 1})}}>点我</button>
            <button onClick={() => {alert(store.getState())}}>store值</button>
        </div>
    )
}
```

首先看第一个例子，看起来很简单。组件挂载后运行一个定时器周期输出`count`的值。当我们点击按钮后，`count`从0变成100，这时候定时器输出的却依然是0而不是100。

再看第二个例子。我们通过`useCallback`创建一个函数，这个函数的作用是输出`count`的值。当我们点击按钮后，`count`从0变成100，这时候执行之前的函数，输出的却也是0而不是100。



简单解释一下。

首先每次操作`count`之后，函数组件都会重新调用一次来渲染页面，这是关键的地方。

对于第一个例子，函数组件第一次调用时创建一个定时器，这个定时器引用了当前函数作用域的`count`变量。因此当函数第二次被调用时，第一个函数作用域下的定时器输出了第一个函数作用域的变量`count`的值，也就是0。

对于第二个例子，函数组件第一次调用时通过`useCallback`创建了一个函数`fn`，这个函数`fn`引用了第一个函数作用域下的`count`变量，由于依赖的是空数组（或者说不依赖于其他值），当函数第二次被调用时，并不会创建一个新的函数`fn`，而是得到一个引用和`fn`相同的函数。所以，在第二个函数作用域下的函数`fn`，引用和第一个函数作用域的`fn`是相同的，所以最后输出的结果也是第一个函数作用域下的`count`，也就是0。



那么想要解决以上问题，只需要让`useCallback`创建的函数依赖某个值即可。

``` js
const fn = useCallback(() => {
    console.log(count)
}, [count]) 
```

这样子，当函数组件第二次被调用后，根据对于前后的依赖值`count`，发现`count`发现变化了，这时候就会重新创建一个新的函数`fn`，此时的函数`fn`的引用和第一次创建的`fn`的引用是不同的。因此这次的函数`fn`所引用的变量`count`，是第二个函数作用域的变量`count`，也就是100。



以前有聊过`useCallback`的作用，通常函数组件每次调用都会生成一个新的作用域，所以可能会经常重复的销毁并生成新的内部函数，造成浪费。`useCallback`允许我们，即使函数组件重新调用，我们也可以得到引用相同的内部函数，除了不会浪费性能这点外，因为引用不同，即使内部函数作为`props`传递给子组件，子组件也不会重新渲染。



但我们也可以看到，为了解决以上的“闭包陷阱”的问题，我们实际上在每次函数组件重新调用之后，都重新创建了内部函数，而`useCallback`最初的理念就是避免这种情况。

在`react`的官方文档中，确实提供了一种方式来解决类似的问题，它所使用的是`useRef`，其实原理很简单。

``` jsx live
function Test3() {
  const [count, setCount] = useState(0);
  const Ref = useRef();

  useEffect(() => {
    Ref.current = count; 
  });

  const fn = useCallback(() => {
    const currentCount = Ref.current; 
    alert(currentCount)
  }, [Ref]); // 

  return (
    <>
      { count }
      <button onClick={() => setCount(100)}>点我</button>
      <button onClick={fn}>输出</button>
    </>
  );
}
```



而在`ahooks`也提供了一个`usePersistFn`提供给我们使用。

``` js
export type noop = (...args: any[]) => any;

function usePersistFn<T extends noop>(fn: T) {
  const ref = useRef<any>(() => {
    throw new Error('Cannot call function while rendering.');
  });

  ref.current = fn;

  const persistFn = useCallback(((...args) => ref.current(...args)) as T, [ref]);

  return persistFn;
}

// 使用
const [count, setCount] = useState(0);
const showCountPersistFn = usePersistFn(() => {
message.info(`Current count is ${count}`);
});
```

本质是`ref`的`current`不断被赋予新的函数`fn`，所以可以拿到新的函数作用域下的值。



参考链接：

[React Hook原理](https://github.com/brickspert/blog/issues/26)

[React useEffect的陷阱](https://zhuanlan.zhihu.com/p/84697185)


